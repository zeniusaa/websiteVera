<!DOCTYPE html>
<html lang="id">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Buat Vera Sayang 3D</title>
  <style>
    html,body { height: 100%; margin: 0; background: #000; overflow: hidden; font-family: Arial, sans-serif; }
  </style>
</head>
<body>
  <div id="canvas-container"></div>

  <!-- Audio musik -->
  <audio id="bg-music" loop>
    <source src="https://cdn.discordapp.com/attachments/741280712866529340/1404634996194676767/D.O_EXO_I_Do_Easy_Lyrics.mp3?ex=689be7c7&is=689a9647&hm=c91508d52f92e0826f3f48e1774060e3b619e9d0d5d304b95551fa3ba3a660d3&" type="audio/mpeg">
  </audio>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://threejs.org/examples/js/geometries/TextGeometry.js"></script>
  <script src="https://threejs.org/examples/js/loaders/FontLoader.js"></script>

  <script>
  let scene, camera, renderer, starField;
  let wordGroup, wordMeshes = [];
  let mouseX = 0, mouseY = 0;
  let targetX = 0, targetY = 0;
  let isRotating = true;
  let starSpeed = 0.001;
  let wordFallSpeed = 0.6;
  let wordCount = 100;
  let loadedFont = null;

  const WORDS = [
    "Love You Sayang Vera ", "Love You Vera Cantikk ", "<3",
    "Sayang Vera Fajriah", "Raka  Vera", "LOVE YOU VERA",
    "Selalu Bersama VERA ", "Sayangku VERA ", "Cintaku Tak Akan Luntur VERA ",
    "Kamu Dunia Aku ", "My Only VERA ", "Cinta VERA Selamanya ",
    "Vera Kesayanganku ", "PELA CAYANGG ",
    "Kamu Segalanya Untukku ", "Aku Cinta Kamu ", "Forever With You "
  ];

  const ROMANTIC_COLORS = [
    0xffb6c1, 0xff69b4, 0xff1493, 0xdb7093, 0xff6347,
    0xff4500, 0xffc0cb, 0xe6a8d7, 0xff7f50, 0xd87093
  ];

  function init() {
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 4000);
    camera.position.z = 200;

    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.getElementById('canvas-container').appendChild(renderer.domElement);

    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);
    const pointLight = new THREE.PointLight(0xffffff, 1);
    pointLight.position.set(200, 200, 200);
    scene.add(pointLight);

    wordGroup = new THREE.Group();
    scene.add(wordGroup);

    createStars();

    const loader = new THREE.FontLoader();
    loader.load('https://threejs.org/examples/fonts/optimer_bold.typeface.json', function(font) {
      loadedFont = font;
      create3DWordRain(wordCount);
    });

    window.addEventListener('resize', onWindowResize);
    document.addEventListener('wheel', onMouseWheel);

    let isDragging = false;
    let lastX = 0, lastY = 0;

    document.addEventListener('mousedown', (e) => {
      isDragging = true;
      lastX = e.clientX;
      lastY = e.clientY;
    });
    document.addEventListener('mousemove', (e) => {
      if (isDragging) {
        mouseX += e.clientX - lastX;
        mouseY += e.clientY - lastY;
        lastX = e.clientX;
        lastY = e.clientY;
      }
    });
    document.addEventListener('mouseup', () => { isDragging = false; });

    document.addEventListener('touchstart', (e) => {
      if (e.touches.length === 1) {
        isDragging = true;
        lastX = e.touches[0].clientX;
        lastY = e.touches[0].clientY;
      }
    });
    document.addEventListener('touchmove', (e) => {
      if (isDragging && e.touches.length === 1) {
        mouseX += e.touches[0].clientX - lastX;
        mouseY += e.touches[0].clientY - lastY;
        lastX = e.touches[0].clientX;
        lastY = e.touches[0].clientY;
      }
    });
    document.addEventListener('touchend', () => { isDragging = false; });

    // Play musik saat klik pertama
    document.body.addEventListener('click', function() {
      const music = document.getElementById('bg-music');
      music.volume = 0.5;
      music.play();
    }, { once: true });

    animate();
  }

  function createStars() {
    const loveShape = new THREE.Shape();
    const x = 0, y = 0;
    loveShape.moveTo(x + 25, y + 25);
    loveShape.bezierCurveTo(x + 25, y + 25, x + 20, y, x, y);
    loveShape.bezierCurveTo(x - 30, y, x - 30, y + 35, x - 30, y + 35);
    loveShape.bezierCurveTo(x - 30, y + 55, x - 10, y + 77, x + 25, y + 95);
    loveShape.bezierCurveTo(x + 60, y + 77, x + 80, y + 55, x + 80, y + 35);
    loveShape.bezierCurveTo(x + 80, y + 35, x + 80, y, x + 50, y);
    loveShape.bezierCurveTo(x + 35, y, x + 25, y + 25, x + 25, y + 25);

    const loveGeometry = new THREE.ShapeBufferGeometry(loveShape);
    loveGeometry.scale(0.1, 0.1, 0.1);

    const loveMaterial = new THREE.MeshBasicMaterial({ side: THREE.DoubleSide });

    const loveCount = 500;
    starField = new THREE.Group();

    for (let i = 0; i < loveCount; i++) {
      const mesh = new THREE.Mesh(loveGeometry, loveMaterial.clone());
      mesh.material.color.setHex(ROMANTIC_COLORS[Math.floor(Math.random() * ROMANTIC_COLORS.length)]);
      const radius = Math.random() * 1000 + 200;
      const theta = Math.random() * Math.PI * 2;
      const phi = Math.acos(Math.random() * 2 - 1);
      mesh.position.set(
        radius * Math.sin(phi) * Math.cos(theta),
        radius * Math.sin(phi) * Math.sin(theta),
        radius * Math.cos(phi)
      );
      mesh.rotation.z = Math.random() * Math.PI;
      starField.add(mesh);
    }

    scene.add(starField);
  }

  function create3DWordRain(count=50) {
    if (!loadedFont) return;

    wordMeshes.forEach(m => {
      if (m.parent) m.parent.remove(m);
      m.geometry.dispose();
      m.material.dispose();
    });
    wordMeshes = [];
    wordGroup.clear();

    for (let i = 0; i < count; i++) {
      const txt = WORDS[Math.floor(Math.random() * WORDS.length)];
      const geom = new THREE.TextGeometry(txt, {
        font: loadedFont,
        size: 8,
        height: 2,
        curveSegments: 8,
        bevelEnabled: true,
        bevelThickness: 0.5,
        bevelSize: 0.3,
        bevelSegments: 2
      });
      const romanticColor = ROMANTIC_COLORS[Math.floor(Math.random() * ROMANTIC_COLORS.length)];
      const mat = new THREE.MeshStandardMaterial({ color: romanticColor });
      const mesh = new THREE.Mesh(geom, mat);

      mesh.position.set((Math.random() - 0.5) * 800, (Math.random() * 600) - 200, (Math.random() - 0.5) * 800);
      mesh.rotation.set((Math.random() - 0.5) * 0.8, (Math.random() - 0.5) * 1.2, (Math.random() - 0.5) * 0.8);

      mesh.userData = {
        fallSpeed: wordFallSpeed * (0.6 + Math.random() * 1.6)
      };

      wordGroup.add(mesh);
      wordMeshes.push(mesh);
    }
  }

  function animate() {
    requestAnimationFrame(animate);
    targetX = mouseX * 0.002;
    targetY = mouseY * 0.002;
    camera.position.x += (targetX * 200 - camera.position.x) * 0.05;
    camera.position.y += (-targetY * 200 - camera.position.y) * 0.05;
    camera.lookAt(0, 0, 0);

    if (isRotating) {
      starField.rotation.x += starSpeed * 0.3;
      starField.rotation.y += starSpeed;
    }

    for (let i = 0; i < wordMeshes.length; i++) {
      const m = wordMeshes[i];
      m.position.y -= m.userData.fallSpeed;
      m.lookAt(camera.position);
      if (m.position.y < -300) {
        m.position.y = 400 + Math.random() * 300;
        m.position.x = (Math.random() - 0.5) * 800;
        m.position.z = (Math.random() - 0.5) * 800;
      }
    }

    renderer.render(scene, camera);
  }

  function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  }

  function onMouseWheel(e) {
    camera.fov += e.deltaY * 0.02;
    camera.fov = Math.max(30, Math.min(120, camera.fov));
    camera.updateProjectionMatrix();
  }

  init();
  </script>
</body>
</html>
